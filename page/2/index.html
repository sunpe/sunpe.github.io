<!doctype html>

<html lang="en">

<head>
  <title>hello world</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="stay foolish, stay hungry" />
<meta name="author" content="sunpeng" />


<meta name="baidu-site-verification" content="vWQN0uJLC2" />
<link rel="alternate" type="application/rss+xml+xml" href="https://sunpe.github.io/index.xml" title="hello world" /><meta property="og:title" content="hello world" />
<meta property="og:description" content="stay foolish, stay hungry" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://sunpe.github.io/" />
<meta property="og:updated_time" content="2020-12-12T22:00:00+08:00" />

<meta name="generator" content="Hugo 0.75.1" />
    

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://sunpe.github.io/fontawesome/css/all.min.css" />
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  
  
  <link rel="stylesheet" type="text/css" href="https://sunpe.github.io/css/styles.css" /></head>

<body>
  <div id="container">
    <header>
      <h1>
        <a href="https://sunpe.github.io/">hello world</a>
      </h1>

      <ul id="social-media">
      </ul>
      
      <p><em>stay foolish, stay hungry</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://sunpe.github.io/">
                <i class="fa-li fa  fa-lg"></i><span>Home</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/posts/">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/tags/">
                <i class="fa-li fa  fa-lg"></i><span>Tags</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/categories/">
                <i class="fa-li fa  fa-lg"></i><span>Categories</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<section id="home">
  <ul>
    
    
    

    <li class="first" >
      <h1><a href="https://sunpe.github.io/posts/2020-07-03-golang-channel/" title="理解Golang channel">理解Golang channel</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-07-03T22:00:00&#43;08:00">Jul 3, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>7 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-07-03-golang-channel/" title="理解Golang channel">
        <img src="">
    </a>
</div>


      <p>channel 是 golang 的核心特性之一，提供了 goroutine 通信的机制，简化了并发模式。
CSP golang 通过 goroutine 和 channel 部分实现了 CSP（Communicating Sequential Process）。CSP 即通信顺序进程，是 Tony Hoare 于 1977 年提出的一种并发模型。CSP 模型由并发执行的实体（线程或者进程）所组成，实体之间通过发送消息进行通信，这里发送消息时使用的就是通道，或者叫 channel。CSP 模型的关键是关注 channel，而不关注发送消息的实体，golang 中 goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。</p>
      
      <a href="https://sunpe.github.io/posts/2020-07-03-golang-channel/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-06-18-golang-panic-defer-recover/" title="golang中的defer, panic和recover">golang中的defer, panic和recover</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-06-18T22:00:00&#43;08:00">Jun 18, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>3 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-06-18-golang-panic-defer-recover/" title="golang中的defer, panic和recover">
        <img src="">
    </a>
</div>


      <p>Go提供了 defer, panic 和 recover 三个内置方法。其中 panic 会让程序崩溃，defer 可以在函数 return 之前执行操作， defer 和 recover 配合可以捕获 panic。
defer defer 声明的语句可以在函数或方法返回（不管是正常返回或异常返回）之前调用，类似于 Java 里面的 finally，可以做一些清理的工作，比如关闭文件、 释放资源等操作。</p>
      
      <a href="https://sunpe.github.io/posts/2020-06-18-golang-panic-defer-recover/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-06-05-golang-runtime-schedule/" title="理解 golang 运行时调度">理解 golang 运行时调度</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-06-05T22:00:00&#43;08:00">Jun 5, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>2 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-06-05-golang-runtime-schedule/" title="理解 golang 运行时调度">
        <img src="">
    </a>
</div>


      <p>操作系统线程（OS thread）对于 golang 来说太重了。而且最重要的是操作系统（OS）无法基于 golang 模型做出正确的调度。比如，GC的时候要暂停所有的线程（go中对应的是 groutine）， 而且内存要处于一致的状态，这需要等待运行中的线程执行到内存一致状态的点（安全点）。当有许多线程时, 为了达到一致状态, 就需要等待这些可能处于任意状态的线程达到一致状态。Golang 的调度器可以做到仅在已知的内存一致状态的点上进行调度。
golang调度器 目前有3种常见的线程模型，一个是N:1模型，即几个用户级线程运行在一个 os 线程，这种模型的优势是可以非常快的进行上下文切换（context switch），缺点是不能充分利用多核 CPU 的优势；另外一个是 1:1 模型，即一个用户级线程对应一个 os 线程，好处是可以利用多核 CPU 的优势，缺点是上下文切换（Content switch）成本比较高。</p>
      
      <a href="https://sunpe.github.io/posts/2020-06-05-golang-runtime-schedule/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-05-22-golang-project-struct/" title="golang 项目结构">golang 项目结构</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-05-22T22:00:00&#43;08:00">May 22, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-05-22-golang-project-struct/" title="golang 项目结构">
        <img src="">
    </a>
</div>


      <p>常见的golang代码布局方式通常有扁平化布局和模块化布局。
扁平化布局 扁平化布局很简单，代码之间不分层，所有代码放在同一个目录。这种布局风格适合比较简单的项目。我们见到的工具包通常就是这种布局，例如 errors 项目的结构：
project | |- bench_test.go | |-errors.go | |-errors_test.go | |-example_test.go | |-format_test.go | |-go113.go | |-go113_test.</p>
      
      <a href="https://sunpe.github.io/posts/2020-05-22-golang-project-struct/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-04-30-dead-lock/" title="死锁条件">死锁条件</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-04-30T22:00:00&#43;08:00">Apr 30, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">#基础知识</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-04-30-dead-lock/" title="死锁条件">
        <img src="">
    </a>
</div>


      <p>死锁（deadlock）是指两个进程被相互阻塞，并且一直处于这样的状态。
大部分死锁都和资源有关，按占用方式来看，资源分为两类：可抢占资源和不可抢占资源。可抢占资源（preemptable resource）可以从拥有它的进程中抢占而不会产生任何副作用；不可抢占资源（nonpreemptable resource）是指不能从当前占用它的进程中强行抢占的资源，必须由拥有者主动释放。
Coffman 总结了发生死锁的四个必要条件：
 相互排斥，并发进程同时拥有资源的独占权。 等待条件，并发进程必须同时拥有一个资源，并等待额外的资源。 不可抢占，并发进程拥有的资源只能被该进程释放。 循环等待，一个并发进程（P1）必须等待一系列的其他并发进程（P2）这些并发进程同时也在等待进程（P1）  死锁发生时，一定同事满足这四个条件，如果其中某一条件不满足，死锁就不会发生。</p>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-04-17-data-struct-queue/" title="数据结构--队列">数据结构--队列</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-04-17T22:00:00&#43;08:00">Apr 17, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#数据结构</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-04-17-data-struct-queue/" title="数据结构--队列">
        <img src="">
    </a>
</div>


      <p>和栈相似，队列（queue）也是表，所不同的是队列的插入在表的一端进行而删除则在另一端进行。与栈的后进先出（LIFO）不同，队列中的元素特性是先进先出（FIFO）。
图 1
队列的基本操作：
 入队，在表的末端，也叫队尾（rear），插入一个元素 出队，删除或返回表的开头，也叫队头（front）的元素  队列的实现 如同栈一样，对于队列而言，任何表的实现都是合法的。对于入队和出队操作，链表和数组的实现都能给出 O(1) 的运行时间。
队列的数组slice实现 对于队列数据结构，我们保留一个数组 []interface、 队头位置 front、 队尾位置 rear 以及队列中元素的个数 size.</p>
      
      <a href="https://sunpe.github.io/posts/2020-04-17-data-struct-queue/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-04-03-data-struct-stack/" title="数据结构--栈">数据结构--栈</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-04-03T22:00:00&#43;08:00">Apr 3, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#数据结构</a>
                
            </em>
        </li>
        

        <li>2 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-04-03-data-struct-stack/" title="数据结构--栈">
        <img src="">
    </a>
</div>


      <p>栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置叫表的末端，或者叫栈顶（top）。由于对栈中所有元素的操作都是在栈顶，所以栈有后进先出（LIFO）的特性。
图 1
栈的基本操作有：
 元素入栈操作 push 元素出栈操作 pop 查看栈顶元素 top  入栈是指在栈顶插入元素，出栈是指删除栈顶元素。
栈的实现 通过链表实现 可以使用单链表来实现栈，链表的前端作为栈顶，通过在链表头插入元素来实现 push，删除表头元素来实现 pop，top 操作只是返回链表头部元素的指。
import ( &#34;container/list&#34; &#34;sync&#34; ) type Stack struct { sync.</p>
      
      <a href="https://sunpe.github.io/posts/2020-04-03-data-struct-stack/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-03-20-data-struct-list/" title="数据结构--列表">数据结构--列表</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-03-20T22:00:00&#43;08:00">Mar 20, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#数据结构</a>
                
            </em>
        </li>
        

        <li>7 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-03-20-data-struct-list/" title="数据结构--列表">
        <img src="">
    </a>
</div>


      <p>形如 A1, A2, A3, … AN这样的表，表大小是 N，大小为 0 的表叫空表。对于空表之外的表 Ai+1 是 Ai 的后继，Ai-1 (i&gt;=1) 是 Ai 的前驱。A1 是表的第一个元素，AN 是表的最后一个元素，A1 没有前驱元素，AN 也没有后继元素。</p>
      
      <a href="https://sunpe.github.io/posts/2020-03-20-data-struct-list/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-02-29-build-blog-with-jekyll/" title="使用 Jekyll 和 Git Page 搭建个人博客">使用 Jekyll 和 Git Page 搭建个人博客</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-02-29T22:00:00&#43;08:00">Feb 29, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E5%B7%A5%E5%85%B7">工具</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2">#个人博客</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-02-29-build-blog-with-jekyll/" title="使用 Jekyll 和 Git Page 搭建个人博客">
        <img src="">
    </a>
</div>


      <p>jekyll 是一个简单的静态网站生成器，可以将 markdown 文档或 html 文档转换成一个完整的可发布的静态网站。并且内置 GitHub Pages 支持。
GitHub Pages 是一项静态站点托管服务，直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，可以通过构建过程运行文件，发布网站。目前 github 支持 3 种类型的 GitHub Pages 站点：project，user 和 organization，具体可以参考github的帮助文档。</p>
      
      <a href="https://sunpe.github.io/posts/2020-02-29-build-blog-with-jekyll/">Read more…</a>
      
    </li>
    
  </ul>
</section>


<ul class="pagination">
  <li class="page-item">
    <a href="https://sunpe.github.io/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item">
    <a href="https://sunpe.github.io/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item">
    <a class="page-link" href="https://sunpe.github.io/">1</a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="https://sunpe.github.io/page/2/">2</a>
  </li>
  <li class="page-item disabled">
    <a  class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="https://sunpe.github.io/page/2/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>





</main>
    <footer>
        <h6>Copyright © 2020 - sunpeng |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://sunpe.github.ioindex.xml">Subscribe </a></h6>
    </footer>
</div>
<script src="https://sunpe.github.io/js/scripts.js"></script>

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-161915530-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?567e1c9bcb80e3b8c4f1c1dbf8bb9fab";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>
</body>

</html>

