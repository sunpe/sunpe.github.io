<!doctype html>

<html lang="en">

<head>
  <title>hello world</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="stay foolish, stay hungry" />
<meta name="author" content="sunpeng" />


<meta name="baidu-site-verification" content="vWQN0uJLC2" />
<link rel="alternate" type="application/rss+xml+xml" href="https://sunpe.github.io/index.xml" title="hello world" /><meta property="og:title" content="hello world" />
<meta property="og:description" content="stay foolish, stay hungry" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://sunpe.github.io/" />
<meta property="og:updated_time" content="2021-02-16T22:00:00+08:00" />

<meta name="generator" content="Hugo 0.75.1" />
    

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://sunpe.github.io/fontawesome/css/all.min.css" />
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  
  
  <link rel="stylesheet" type="text/css" href="https://sunpe.github.io/css/styles.css" /></head>

<body>
  <div id="container">
    <header>
      <h1>
        <a href="https://sunpe.github.io/">hello world</a>
      </h1>

      <ul id="social-media">
      </ul>
      
      <p><em>stay foolish, stay hungry</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://sunpe.github.io/">
                <i class="fa-li fa  fa-lg"></i><span>Home</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/posts/">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/tags/">
                <i class="fa-li fa  fa-lg"></i><span>Tags</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/categories/">
                <i class="fa-li fa  fa-lg"></i><span>Categories</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<section id="home">
  <ul>
    
    
    

    <li class="first" >
      <h1><a href="https://sunpe.github.io/posts/2020-07-31-golang-escape/" title="golang语言机制之逃逸分析">golang语言机制之逃逸分析</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-07-31T22:00:00&#43;08:00">Jul 31, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>3 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-07-31-golang-escape/" title="golang语言机制之逃逸分析">
        <img src="">
    </a>
</div>


      <p>Golang 中逃逸是指栈空间的变量逃逸到了堆空间，逃逸分析是编译器通过静态代码分析决定程序中变量存储位置的过程。代码中没有任何的关键词或者函数可以决定变量放置在栈空间还是堆空间，只能让编译器通过代码来决定变量值的存储位置。
堆（Heaps） 堆是内存中除了栈之外用来存储变量值的区域，堆不能像栈一样自己释放空间，所以使用这块区域会比使用栈有更大的开销。其中开销主要用来进行垃圾回收（GC），当进行垃圾回收时，会消耗 25% 的 CPU，并且很可能会造成微秒级的「stop the world」延迟。而 GC 的好处是不需要再手动来分配和释放内存。Golang 中一部分变量值分配在堆上，而不在使用的变量值都需要清理掉，堆上的数据过多会给 GC 造成压力。
共享栈（Sharing Stacks） Golang 不允许 goroutine 访问其他 goroutine 的栈空间，这是因为 goroutine 的栈空间增长或收缩时，栈空间会填充进新的内容。</p>
      
      <a href="https://sunpe.github.io/posts/2020-07-31-golang-escape/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-07-17-golang-stack-and-pointer/" title="golang语言机制之栈与指针">golang语言机制之栈与指针</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-07-17T22:00:00&#43;08:00">Jul 17, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>3 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-07-17-golang-stack-and-pointer/" title="golang语言机制之栈与指针">
        <img src="">
    </a>
</div>


      <p>学习和使用 golang，就不得不了解 golang 的指针。如果不能很好的理解指针，很难写出简单、整洁并高效的代码。
帧边界（Frame Boundaries） 帧边界为函数执行提供了独有的内存空间、上下文（context）环境和一些流控制。函数可以通过帧边界指针直接访问帧边界的内存，或者间接访问帧边界外的内存（不能直接访问帧边界外的内存）。函数要间接访问帧边界外的内存，被访问的内存必须和函数共享。我们首先来了解一下帧边界建立的机制和限制。
函数调用时，会在两个相关的帧边界间进行切换，从调用函数切换到被调用函数，如果函数调用时需要传递参数，那么这些参数值也要传递到被调用函数的帧边界中。Go 语言中帧边界间的数据传递是按值（by value）传递的。
按值传递的好处是可读性好，函数调用时传入的值就是函数真正接收到的值。按值传递又叫做 WYSIWYG（what you see is what you get）。在发生切换时，我们可以很清楚的了解函数调用将如何影响程序执行。
程序 1 展示了函数调用按值传递。</p>
      
      <a href="https://sunpe.github.io/posts/2020-07-17-golang-stack-and-pointer/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-07-03-golang-channel/" title="理解Golang channel">理解Golang channel</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-07-03T22:00:00&#43;08:00">Jul 3, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>7 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-07-03-golang-channel/" title="理解Golang channel">
        <img src="">
    </a>
</div>


      <p>channel 是 golang 的核心特性之一，提供了 goroutine 通信的机制，简化了并发模式。
CSP golang 通过 goroutine 和 channel 部分实现了 CSP（Communicating Sequential Process）。CSP 即通信顺序进程，是 Tony Hoare 于 1977 年提出的一种并发模型。CSP 模型由并发执行的实体（线程或者进程）所组成，实体之间通过发送消息进行通信，这里发送消息时使用的就是通道，或者叫 channel。CSP 模型的关键是关注 channel，而不关注发送消息的实体，golang 中 goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。</p>
      
      <a href="https://sunpe.github.io/posts/2020-07-03-golang-channel/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-06-18-golang-panic-defer-recover/" title="golang中的defer, panic和recover">golang中的defer, panic和recover</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-06-18T22:00:00&#43;08:00">Jun 18, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>3 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-06-18-golang-panic-defer-recover/" title="golang中的defer, panic和recover">
        <img src="">
    </a>
</div>


      <p>Go提供了 defer, panic 和 recover 三个内置方法。其中 panic 会让程序崩溃，defer 可以在函数 return 之前执行操作， defer 和 recover 配合可以捕获 panic。
defer defer 声明的语句可以在函数或方法返回（不管是正常返回或异常返回）之前调用，类似于 Java 里面的 finally，可以做一些清理的工作，比如关闭文件、 释放资源等操作。</p>
      
      <a href="https://sunpe.github.io/posts/2020-06-18-golang-panic-defer-recover/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-06-05-golang-runtime-schedule/" title="理解 golang 运行时调度">理解 golang 运行时调度</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-06-05T22:00:00&#43;08:00">Jun 5, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>2 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-06-05-golang-runtime-schedule/" title="理解 golang 运行时调度">
        <img src="">
    </a>
</div>


      <p>操作系统线程（OS thread）对于 golang 来说太重了。而且最重要的是操作系统（OS）无法基于 golang 模型做出正确的调度。比如，GC的时候要暂停所有的线程（go中对应的是 groutine）， 而且内存要处于一致的状态，这需要等待运行中的线程执行到内存一致状态的点（安全点）。当有许多线程时, 为了达到一致状态, 就需要等待这些可能处于任意状态的线程达到一致状态。Golang 的调度器可以做到仅在已知的内存一致状态的点上进行调度。
golang调度器 目前有3种常见的线程模型，一个是N:1模型，即几个用户级线程运行在一个 os 线程，这种模型的优势是可以非常快的进行上下文切换（context switch），缺点是不能充分利用多核 CPU 的优势；另外一个是 1:1 模型，即一个用户级线程对应一个 os 线程，好处是可以利用多核 CPU 的优势，缺点是上下文切换（Content switch）成本比较高。</p>
      
      <a href="https://sunpe.github.io/posts/2020-06-05-golang-runtime-schedule/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-05-22-golang-project-struct/" title="golang 项目结构">golang 项目结构</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-05-22T22:00:00&#43;08:00">May 22, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-05-22-golang-project-struct/" title="golang 项目结构">
        <img src="">
    </a>
</div>


      <p>常见的golang代码布局方式通常有扁平化布局和模块化布局。
扁平化布局 扁平化布局很简单，代码之间不分层，所有代码放在同一个目录。这种布局风格适合比较简单的项目。我们见到的工具包通常就是这种布局，例如 errors 项目的结构：
project | |- bench_test.go | |-errors.go | |-errors_test.go | |-example_test.go | |-format_test.go | |-go113.go | |-go113_test.</p>
      
      <a href="https://sunpe.github.io/posts/2020-05-22-golang-project-struct/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-04-30-dead-lock/" title="死锁条件">死锁条件</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-04-30T22:00:00&#43;08:00">Apr 30, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">#基础知识</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-04-30-dead-lock/" title="死锁条件">
        <img src="">
    </a>
</div>


      <p>死锁（deadlock）是指两个进程被相互阻塞，并且一直处于这样的状态。
大部分死锁都和资源有关，按占用方式来看，资源分为两类：可抢占资源和不可抢占资源。可抢占资源（preemptable resource）可以从拥有它的进程中抢占而不会产生任何副作用；不可抢占资源（nonpreemptable resource）是指不能从当前占用它的进程中强行抢占的资源，必须由拥有者主动释放。
Coffman 总结了发生死锁的四个必要条件：
 相互排斥，并发进程同时拥有资源的独占权。 等待条件，并发进程必须同时拥有一个资源，并等待额外的资源。 不可抢占，并发进程拥有的资源只能被该进程释放。 循环等待，一个并发进程（P1）必须等待一系列的其他并发进程（P2）这些并发进程同时也在等待进程（P1）  死锁发生时，一定同事满足这四个条件，如果其中某一条件不满足，死锁就不会发生。</p>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-04-17-data-struct-queue/" title="数据结构--队列">数据结构--队列</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-04-17T22:00:00&#43;08:00">Apr 17, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#数据结构</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-04-17-data-struct-queue/" title="数据结构--队列">
        <img src="">
    </a>
</div>


      <p>和栈相似，队列（queue）也是表，所不同的是队列的插入在表的一端进行而删除则在另一端进行。与栈的后进先出（LIFO）不同，队列中的元素特性是先进先出（FIFO）。
图 1
队列的基本操作：
 入队，在表的末端，也叫队尾（rear），插入一个元素 出队，删除或返回表的开头，也叫队头（front）的元素  队列的实现 如同栈一样，对于队列而言，任何表的实现都是合法的。对于入队和出队操作，链表和数组的实现都能给出 O(1) 的运行时间。
队列的数组slice实现 对于队列数据结构，我们保留一个数组 []interface、 队头位置 front、 队尾位置 rear 以及队列中元素的个数 size.</p>
      
      <a href="https://sunpe.github.io/posts/2020-04-17-data-struct-queue/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-04-03-data-struct-stack/" title="数据结构--栈">数据结构--栈</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-04-03T22:00:00&#43;08:00">Apr 3, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#数据结构</a>
                
            </em>
        </li>
        

        <li>2 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-04-03-data-struct-stack/" title="数据结构--栈">
        <img src="">
    </a>
</div>


      <p>栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置叫表的末端，或者叫栈顶（top）。由于对栈中所有元素的操作都是在栈顶，所以栈有后进先出（LIFO）的特性。
图 1
栈的基本操作有：
 元素入栈操作 push 元素出栈操作 pop 查看栈顶元素 top  入栈是指在栈顶插入元素，出栈是指删除栈顶元素。
栈的实现 通过链表实现 可以使用单链表来实现栈，链表的前端作为栈顶，通过在链表头插入元素来实现 push，删除表头元素来实现 pop，top 操作只是返回链表头部元素的指。
import ( &#34;container/list&#34; &#34;sync&#34; ) type Stack struct { sync.</p>
      
      <a href="https://sunpe.github.io/posts/2020-04-03-data-struct-stack/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-03-20-data-struct-list/" title="数据结构--列表">数据结构--列表</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-03-20T22:00:00&#43;08:00">Mar 20, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#数据结构</a>
                
            </em>
        </li>
        

        <li>7 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-03-20-data-struct-list/" title="数据结构--列表">
        <img src="">
    </a>
</div>


      <p>形如 A1, A2, A3, … AN这样的表，表大小是 N，大小为 0 的表叫空表。对于空表之外的表 Ai+1 是 Ai 的后继，Ai-1 (i&gt;=1) 是 Ai 的前驱。A1 是表的第一个元素，AN 是表的最后一个元素，A1 没有前驱元素，AN 也没有后继元素。</p>
      
      <a href="https://sunpe.github.io/posts/2020-03-20-data-struct-list/">Read more…</a>
      
    </li>
    
  </ul>
</section>


<ul class="pagination">
  <li class="page-item">
    <a href="https://sunpe.github.io/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item">
    <a href="https://sunpe.github.io/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item">
    <a class="page-link" href="https://sunpe.github.io/">1</a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="https://sunpe.github.io/page/2/">2</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="https://sunpe.github.io/page/3/">3</a>
  </li>
  <li class="page-item">
    <a href="https://sunpe.github.io/page/3/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="https://sunpe.github.io/page/3/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>





</main>
    <footer>
        <h6>Copyright © 2020 - sunpeng |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://sunpe.github.io/index.xml">Subscribe </a></h6>
    </footer>
</div>
<script src="https://sunpe.github.io/js/scripts.js"></script>

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-161915530-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?567e1c9bcb80e3b8c4f1c1dbf8bb9fab";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>
</body>

</html>

