<!doctype html>

<html lang="en">

<head>
  <title>理解Golang channel - hello world</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="stay foolish, stay hungry" />
<meta name="author" content="sunpeng" />


<meta name="baidu-site-verification" content="vWQN0uJLC2" />
<meta property="og:title" content="理解Golang channel" />
<meta property="og:description" content="channel 是 golang 的核心特性之一，提供了 goroutine 通信的机制，简化了并发模式。
CSP golang 通过 goroutine 和 channel 部分实现了 CSP（Communicating Sequential Process）。CSP 即通信顺序进程，是 Tony Hoare 于 1977 年提出的一种并发模型。CSP 模型由并发执行的实体（线程或者进程）所组成，实体之间通过发送消息进行通信，这里发送消息时使用的就是通道，或者叫 channel。CSP 模型的关键是关注 channel，而不关注发送消息的实体，golang 中 goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sunpe.github.io/posts/2020-07-03-golang-channel/" />
<meta property="article:published_time" content="2020-07-03T22:00:00+08:00" />
<meta property="article:modified_time" content="2020-07-03T22:00:00+08:00" />

<meta name="generator" content="Hugo 0.75.1" />
    

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://sunpe.github.io/fontawesome/css/all.min.css" />
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  
  
  <link rel="stylesheet" type="text/css" href="https://sunpe.github.io/css/styles.css" /></head>

<body>
  <div id="container">
    <header>
      <h1>
        <a href="https://sunpe.github.io/">hello world</a>
      </h1>

      <ul id="social-media">
      </ul>
      
      <p><em>stay foolish, stay hungry</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://sunpe.github.io/">
                <i class="fa-li fa  fa-lg"></i><span>Home</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/posts/">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/tags/">
                <i class="fa-li fa  fa-lg"></i><span>Tags</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/categories/">
                <i class="fa-li fa  fa-lg"></i><span>Categories</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>理解Golang channel</h1>

    
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-07-03T22:00:00&#43;08:00">Jul 3, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>7 minutes read</li>
    </ul>
</aside>

    

    
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-07-03-golang-channel/" title="理解Golang channel">
        <img src="">
    </a>
</div>



    <p>channel 是 golang 的核心特性之一，提供了 goroutine 通信的机制，简化了并发模式。</p>
<h2 id="csp">CSP</h2>
<p>golang 通过 goroutine 和 channel 部分实现了 CSP（Communicating Sequential Process）。CSP 即通信顺序进程，是 Tony Hoare 于 1977 年提出的一种并发模型。CSP 模型由并发执行的实体（线程或者进程）所组成，实体之间通过发送消息进行通信，这里发送消息时使用的就是通道，或者叫 channel。CSP 模型的关键是关注 channel，而不关注发送消息的实体，golang 中 goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。</p>
<h2 id="channel基础">channel基础</h2>
<p>channel 底层是 hchan 结构体，源码在 src/runtime/chan.go。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">hchan</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">qcount</span>   <span style="color:#66d9ef">uint</span>           <span style="color:#75715e">// total data in the queue
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dataqsiz</span> <span style="color:#66d9ef">uint</span>           <span style="color:#75715e">// 队列大小, 值大于0表示有缓冲, 值等于0表示没有缓冲
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">buf</span>      <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// 缓冲队列buffer的指针
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">elemsize</span> <span style="color:#66d9ef">uint16</span> <span style="color:#75715e">// 单个元素大小
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">closed</span>   <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// 关闭标识符
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">elemtype</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span> <span style="color:#75715e">// 元素类型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sendx</span>    <span style="color:#66d9ef">uint</span>   <span style="color:#75715e">// 发送数据索引
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">recvx</span>    <span style="color:#66d9ef">uint</span>   <span style="color:#75715e">// 接收数据索引
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">recvq</span>    <span style="color:#a6e22e">waitq</span>  <span style="color:#75715e">// 等待接收数据的sudog(goroutine)链表
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sendq</span>    <span style="color:#a6e22e">waitq</span>  <span style="color:#75715e">// 等待发送数据的sudog(goroutine)链表
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// lock protects all fields in hchan, as well as several
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// fields in sudogs blocked on this channel.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Do not change another G&#39;s status while holding this lock
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// (in particular, do not ready a G), as this can deadlock
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// with stack shrinking.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">mutex</span>
}
</code></pre></div><p>sudog 表示在等待队列中的 goroutine。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 2
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">sudog</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#75715e">// The following fields are protected by the hchan.lock of the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// channel this sudog is blocking on. shrinkstack depends on
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// this for sudogs involved in channel ops.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>
    <span style="color:#75715e">// isSelect indicates g is participating in a select, so
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// g.selectDone must be CAS&#39;d to win the wake-up race.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">isSelect</span> <span style="color:#66d9ef">bool</span>
    <span style="color:#a6e22e">next</span>     <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span>
    <span style="color:#a6e22e">prev</span>     <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span>
    <span style="color:#a6e22e">elem</span>     <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// data element (may point to stack)
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// The following fields are never accessed concurrently.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// For channels, waitlink is only accessed by g.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// For semaphores, all fields (including the ones above)
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// are only accessed when holding a semaRoot lock.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">acquiretime</span> <span style="color:#66d9ef">int64</span>
    <span style="color:#a6e22e">releasetime</span> <span style="color:#66d9ef">int64</span>
    <span style="color:#a6e22e">ticket</span>      <span style="color:#66d9ef">uint32</span>
    <span style="color:#a6e22e">parent</span>      <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span> <span style="color:#75715e">// semaRoot binary tree
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">waitlink</span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span> <span style="color:#75715e">// g.waiting list or semaRoot
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">waittail</span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span> <span style="color:#75715e">// semaRoot
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">c</span>           <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span> <span style="color:#75715e">// channel
</span><span style="color:#75715e"></span>}
</code></pre></div><h2 id="创建channel">创建channel</h2>
<p>通过内置的 make 函数可以创建带缓冲区或不带缓冲区的 channel：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 3
</span><span style="color:#75715e"></span><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">Task</span>) <span style="color:#75715e">// 创建非缓冲channel
</span><span style="color:#75715e"></span><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">Task</span>, <span style="color:#ae81ff">3</span>) <span style="color:#75715e">// 创建缓冲channel
</span></code></pre></div><p><img src="https://sunpe.github.io/images/golang_channel/1.png" alt=""></p>
<p>make 函数创建并实例化 hchan 结构体，并返回 hchan 的指针，所以我们可以直接将 channel 作为方法的参数。</p>
<p><img src="https://sunpe.github.io/images/golang_channel/2.png" alt=""></p>
<p>创建 channel 的函数是 <code>func makechan(t *chantype, size int) *hchan</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 4
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makechan</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">chantype</span>, <span style="color:#a6e22e">size</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span> {
    <span style="color:#a6e22e">elem</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">elem</span>
        <span style="color:#75715e">// 安全检测
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// compiler checks this but be safe.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">elem</span>.<span style="color:#a6e22e">size</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">16</span> {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;makechan: invalid channel element type&#34;</span>)
    }
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">hchanSize</span><span style="color:#f92672">%</span><span style="color:#a6e22e">maxAlign</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">elem</span>.<span style="color:#a6e22e">align</span> &gt; <span style="color:#a6e22e">maxAlign</span> {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;makechan: bad alignment&#34;</span>)
    }
    <span style="color:#a6e22e">mem</span>, <span style="color:#a6e22e">overflow</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MulUintptr</span>(<span style="color:#a6e22e">elem</span>.<span style="color:#a6e22e">size</span>, uintptr(<span style="color:#a6e22e">size</span>))
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">overflow</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">mem</span> &gt; <span style="color:#a6e22e">maxAlloc</span><span style="color:#f92672">-</span><span style="color:#a6e22e">hchanSize</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">size</span> &lt; <span style="color:#ae81ff">0</span> {
        panic(<span style="color:#a6e22e">plainError</span>(<span style="color:#e6db74">&#34;makechan: size out of range&#34;</span>))
    }
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>
    <span style="color:#66d9ef">switch</span> {
    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">mem</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#75715e">// 如果队列或元素大小是0，则不分配buffer
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Queue or element size is zero.
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">c</span> = (<span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>)(<span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">hchanSize</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">true</span>))
                <span style="color:#75715e">// 将buf指向自身，不分配缓存空间
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Race detector uses this location for synchronization.
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">raceaddr</span>()
    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">elem</span>.<span style="color:#a6e22e">ptrdata</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#75715e">// 如果元素不包含指针，则分配一整块内存，用于hchan和buf
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Elements do not contain pointers.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Allocate hchan and buf in one call.
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">c</span> = (<span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>)(<span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">hchanSize</span><span style="color:#f92672">+</span><span style="color:#a6e22e">mem</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">true</span>))
        <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">c</span>), <span style="color:#a6e22e">hchanSize</span>)
    <span style="color:#66d9ef">default</span>:
                <span style="color:#75715e">// 如果是指针类型，正常创建结构体，buf单独分配空间
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Elements contain pointers.
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">c</span> = new(<span style="color:#a6e22e">hchan</span>)
        <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">mem</span>, <span style="color:#a6e22e">elem</span>, <span style="color:#66d9ef">true</span>)
    }
        <span style="color:#75715e">// 设置channel的属性
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemsize</span> = uint16(<span style="color:#a6e22e">elem</span>.<span style="color:#a6e22e">size</span>)
    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span> = <span style="color:#a6e22e">elem</span>
    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dataqsiz</span> = uint(<span style="color:#a6e22e">size</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">debugChan</span> {
        print(<span style="color:#e6db74">&#34;makechan: chan=&#34;</span>, <span style="color:#a6e22e">c</span>, <span style="color:#e6db74">&#34;; elemsize=&#34;</span>, <span style="color:#a6e22e">elem</span>.<span style="color:#a6e22e">size</span>, <span style="color:#e6db74">&#34;; 
</span><span style="color:#e6db74">                    dataqsiz=&#34;</span>, <span style="color:#a6e22e">size</span>, <span style="color:#e6db74">&#34;\n&#34;</span>)
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>
}
</code></pre></div><h2 id="使用channel">使用channel</h2>
<h3 id="发送和接收数据过程">发送和接收数据过程</h3>
<p><img src="https://sunpe.github.io/images/golang_channel/3.png" alt=""></p>
<p>G1 是生产者，G2 是消费者，<code>ch</code> 是容量为 3 的带缓冲 channel，初始的时候 <code>hchan</code> 结构体的 buf 为空，<code>sendx</code> 和 <code>recvx</code> 都为0。G1 获取锁，并将 task 发送到 channel，并增加 sendx，发送到 channel 中的数据其实是task的副本。然后 G2 获取锁，并从 channel 中获取数据，并增加 recvx，取到的数据依旧是 task 的副本。channel 受互斥锁保护，传递副本可以保证数据的安全。</p>
<p>整个过程没有内存共享（shared memory），充分体现了 CSP 的 do not communicate by sharing memory; instead, share memory by communicating。</p>
<h3 id="blockingunblocking过程">blocking/unblocking过程</h3>
<p><img src="https://sunpe.github.io/images/golang_channel/4.png" alt=""></p>
<p>如果 G2 的读取速度比 G1 的写入速度慢，那么一段时间之后，channe l的 buffer 会被塞满。当 channel 满了之后 G1 继续往 channel 中发送数据。G1 会 block。基于 golang 的调度模型，暂停的其实是 goroutine，而不是 os 线程。</p>
<p><img src="https://sunpe.github.io/images/golang_channel/5.png" alt=""></p>
<p>如果需要 block G1，G1 会创建一个 sudog，放到 channel 的 <code>sendq</code> 中，当 channel 的 buffer 有了空间时，G2 会从 <code>sendq</code> 中 pop 出 <code>sudog</code>，取出 elem，将 G1 状态变成 <code>runnable</code>，调度器就可以再次调度 G1 了。</p>
<p><img src="https://sunpe.github.io/images/golang_channel/6.png" alt=""></p>
<p>如果 G2 先运行，这时候 channel 中没有数据，G2 从一个空的 channel 中读取数据，G2 也会 block，和 G1 block 的逻辑相似，G2 也会创建 <code>sudog</code>，然后放到 <code>recvq</code> 中。</p>
<p><img src="https://sunpe.github.io/images/golang_channel/7.png" alt=""></p>
<p>当此时 G1 向 channel 发送数据，runtime 会直接将 G1 要发送的数据 copy 到 G2 的栈空间，看起来就好像是 G1 直接将数据发送给了 G2，这个过程叫「direct send」，整个过程 G1 和 G2 都不需要再获取锁和读写 buffer。</p>
<p><img src="https://sunpe.github.io/images/golang_channel/8.png" alt=""></p>
<p>非缓冲 channel 总是「direct send」的，如果 receiver 先运行，sender 直接将数据写入 receiver 的栈空间，如果 sennder 先运行，receiver 直接从 sudog 接收数据。</p>
<h2 id="向channel发送数据的源码">向channel发送数据的源码</h2>
<p>发送数据对应的方法是 <code>func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool</code>。</p>
<ol>
<li>如果向 nil channel 发送数据，会一直block：</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 5
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">block</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
    }
    <span style="color:#a6e22e">gopark</span>(<span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">waitReasonChanSendNilChan</span>, <span style="color:#a6e22e">traceEvGoStop</span>, <span style="color:#ae81ff">2</span>)
    <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;unreachable&#34;</span>)
}
</code></pre></div><p><code>gopark</code> 表示将当前 goroutine 休眠，但是 unlockf 是 nil，所以 goroutine 会一直休眠。如果所有 goroutine 都处于休眠状态，在 runtime 的 <code>checkdead()</code> 会检测异常情况, 抛出 <code>all goroutines are asleep - deadlock!</code></p>
<ol start="2">
<li>如果 <code>recvq</code> 中有等待的 sudog：</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 6
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvq</span>.<span style="color:#a6e22e">dequeue</span>(); <span style="color:#a6e22e">sg</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#75715e">// Found a waiting receiver. We pass the value we want to send
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// directly to the receiver, bypassing the channel buffer (if any).
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">sg</span>, <span style="color:#a6e22e">ep</span>, <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>) }, <span style="color:#ae81ff">3</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}
</code></pre></div><p>这里直接将数据复制给 receiver，即上文提到的「direct send」。</p>
<ol start="3">
<li>如果 buffered channel 并且 buffer 有空间：</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 7
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span> &lt; <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dataqsiz</span> {
    <span style="color:#75715e">// Space is available in the channel buffer. Enqueue the element to send.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">qp</span>: = <span style="color:#a6e22e">chanbuf</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">raceenabled</span> {
        <span style="color:#a6e22e">raceacquire</span>(<span style="color:#a6e22e">qp</span>)
        <span style="color:#a6e22e">racerelease</span>(<span style="color:#a6e22e">qp</span>)
    }
    <span style="color:#a6e22e">typedmemmove</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">qp</span>, <span style="color:#a6e22e">ep</span>)
    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span><span style="color:#f92672">++</span>
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dataqsiz</span> {
        <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span> = <span style="color:#ae81ff">0</span>
    }
    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span><span style="color:#f92672">++</span>
    <span style="color:#a6e22e">unlock</span>( <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}
</code></pre></div><p>通过 <code>qcount</code> 和 <code>dataqsiz</code> 属性判断 <code>hchan.buf</code> 是否有可用空间，如果 buffer 有空间，则将数据 copy 进 buffer。</p>
<ol start="4">
<li>如果 buffer 满了，或者没开启 buffer，则 block。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 8
</span><span style="color:#75715e">// Block on the channel. Some receiver will complete our operation for us.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
<span style="color:#a6e22e">mysg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">acquireSudog</span>()
<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">releasetime</span> = <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t0</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
    <span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">releasetime</span> = <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
}
<span style="color:#75715e">// No stack splits between assigning elem and enqueuing mysg
</span><span style="color:#75715e">// on gp.waiting where copystack can find it.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">elem</span> = <span style="color:#a6e22e">ep</span>
<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">waitlink</span> = <span style="color:#66d9ef">nil</span>
<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">g</span> = <span style="color:#a6e22e">gp</span>
<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">isSelect</span> = <span style="color:#66d9ef">false</span>
<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">c</span> = <span style="color:#a6e22e">c</span>
<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">waiting</span> = <span style="color:#a6e22e">mysg</span>
<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">param</span> = <span style="color:#66d9ef">nil</span>
<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendq</span>.<span style="color:#a6e22e">enqueue</span>(<span style="color:#a6e22e">mysg</span>)
<span style="color:#a6e22e">gopark</span>(<span style="color:#a6e22e">chanparkcommit</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>), <span style="color:#a6e22e">waitReasonChanSend</span>, 
    <span style="color:#a6e22e">traceEvGoBlockSend</span>, <span style="color:#ae81ff">2</span>)
</code></pre></div><h2 id="从channel读取数据的源码">从channel读取数据的源码</h2>
<p>读取数据对应的方法是 <code>func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)</code>。</p>
<ol>
<li>如果从 nil channel 中接受数据会一直 block。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 9
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">block</span> {
    <span style="color:#66d9ef">return</span>
    }
    <span style="color:#a6e22e">gopark</span>(<span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">waitReasonChanReceiveNilChan</span>, <span style="color:#a6e22e">traceEvGoStop</span>, <span style="color:#ae81ff">2</span>)
    <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;unreachable&#34;</span>)
}
</code></pre></div><p>和向 nil channel 发送数据类似，从 nil channel 接收数据也会一直 block。</p>
<ol start="2">
<li>从 closed 状态的channel接受数据：</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 10
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">closed</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">raceenabled</span> {
        <span style="color:#a6e22e">raceacquire</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">raceaddr</span>())
    }
    <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ep</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">typedmemclr</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">ep</span>)
    }
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>
}
</code></pre></div><p>如果 buffer 中有数据（<code>if raceenabled</code>），则返回 buffer 中的数据；如果 buffer 中没数据了，则返回默认值，并且第二个返回参数返回 false。</p>
<ol start="3">
<li>如果 <code>sendq</code> 中有等待发送的 <code>sudgo</code></li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 11
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendq</span>.<span style="color:#a6e22e">dequeue</span>(); <span style="color:#a6e22e">sg</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#75715e">// Found a waiting sender. If buffer is size 0, receive value
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// directly from sender. Otherwise, receive from head of queue
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// and add sender&#39;s value to the tail of the queue (both map to
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the same buffer slot because the queue is full).
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">recv</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">sg</span>, <span style="color:#a6e22e">ep</span>, <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>) }, <span style="color:#ae81ff">3</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>
}
</code></pre></div><p>说明队列已满，如果没开启 buffer，则直接从 sender 读取数据。否则，从队列头读取数据，并把 sender 的数据放到队列尾（由于 buffer 是循环队列, 所以队列尾就是刚才读取数据的位置）。</p>
<ol start="4">
<li>如果队列中有数据</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 12
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span> &gt; <span style="color:#ae81ff">0</span> {
    <span style="color:#75715e">// Receive directly from queue
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">qp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">chanbuf</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">raceenabled</span> {
        <span style="color:#a6e22e">raceacquire</span>(<span style="color:#a6e22e">qp</span>)
        <span style="color:#a6e22e">racerelease</span>(<span style="color:#a6e22e">qp</span>)
    }
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ep</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">typedmemmove</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">ep</span>, <span style="color:#a6e22e">qp</span>)
    }
    <span style="color:#a6e22e">typedmemclr</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">qp</span>)
    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span><span style="color:#f92672">++</span>
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dataqsiz</span> {
        <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span> = <span style="color:#ae81ff">0</span>
    }
    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span><span style="color:#f92672">--</span>
    <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>
}
</code></pre></div><p>如果队列中有数据，则直接从队列中读取数据。</p>
<ol start="5">
<li>如果队列中没数据，也没有 goroutine 向队列中发送数据</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 程序 13
</span><span style="color:#75715e"></span><span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
<span style="color:#a6e22e">mysg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">acquireSudog</span>()
<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">releasetime</span> = <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t0</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
    <span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">releasetime</span> = <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
}
<span style="color:#75715e">// No stack splits between assigning elem and enqueuing mysg
</span><span style="color:#75715e">// on gp.waiting where copystack can find it.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">elem</span> = <span style="color:#a6e22e">ep</span>
<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">waitlink</span> = <span style="color:#66d9ef">nil</span>
<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">waiting</span> = <span style="color:#a6e22e">mysg</span>
<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">g</span> = <span style="color:#a6e22e">gp</span>
<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">isSelect</span> = <span style="color:#66d9ef">false</span>
<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">c</span> = <span style="color:#a6e22e">c</span>
<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">param</span> = <span style="color:#66d9ef">nil</span>
<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvq</span>.<span style="color:#a6e22e">enqueue</span>(<span style="color:#a6e22e">mysg</span>)
<span style="color:#a6e22e">gopark</span>(<span style="color:#a6e22e">chanparkcommit</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>), <span style="color:#a6e22e">waitReasonChanReceive</span>, 
    <span style="color:#a6e22e">traceEvGoBlockRecv</span>, <span style="color:#ae81ff">2</span>)
</code></pre></div><p>如果队列中没数据，也没有 goroutine 向队列中发送数据，goroutine 会 block。</p>
<h2 id="channel是否必须close">channel是否必须close</h2>
<p>channel 可以不关闭，如果 channel 不再被使用，即使不关闭也会被回收。通常 close channel 会作为 channel 不会再有数据的控制信号，如果接收方不关心 channel 中是否还会有数据，那么没必要主动关闭 channel。可以参考 <a href="https://groups.google.com/d/msg/golang-nuts/pZwdYRGxCIk/qpbHxRRPJdUJ">Design Question: Channel Closing</a>。如果要关闭 channel，则最好是由发送方来关闭。</p>
<blockquote>
<p>Note that it is only necessary to close a channel if the receiver is looking for a close. Closing the channel is a control signal on the channel indicating that no more data follows.</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>这篇文章描述了 channel 的基本用法和内部的机制，我们从这篇文章了解到了：</p>
<ul>
<li>channel 的零值是nil，必须初始化才能使用。</li>
<li>发送的是数据的副本，但是发送指针或引用类型不是 goroutine 安全的，receiver 接收到的数据可能被 sender 修改。</li>
<li>往一个已经 closed 的 channel 中发送数据会导致 panic，往 nil channel 发送数据会 block。从一个 nil channel 中接收数据会 block，从一个被 close 的 channel 中接收数据不会 block，如果队列中有数据，则正常读取，否则立即返元素类型的零值。</li>
<li><code>select case</code> 中，如果有多个 case 就绪，那么会随机选择一个 case 执行，select 中的 break 只能跳到 select 这一层，select 中一般配合 label 来使用 break。</li>
<li>channel 使用完可以不关闭, 如果要关闭, 最好是发送方来关闭.</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://about.sourcegraph.com/go/understanding-channels-kavya-joshi">https://about.sourcegraph.com/go/understanding-channels-kavya-joshi</a></li>
<li><a href="https://github.com/gophercon/2017-talks/blob/master/KavyaJoshi-UnderstandingChannels/Kavya%20Joshi%20-%20Understanding%20Channels.pdf">https://github.com/gophercon/2017-talks/blob/master/KavyaJoshi-UnderstandingChannels/Kavya Joshi - Understanding Channels.pdf</a></li>
</ol>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://sunpe.github.io/posts/2020-06-18-golang-panic-defer-recover/"><i class="fa fa-chevron-circle-left"></i> golang中的defer, panic和recover</a>
        </li>
        
        
        <li>
            <a href="https://sunpe.github.io/posts/2020-07-17-golang-stack-and-pointer/">golang语言机制之栈与指针 <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
  
    
    
  





</main>
    <footer>
        <h6>Copyright © 2020 - sunpeng |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://sunpe.github.io/index.xml">Subscribe </a></h6>
    </footer>
</div>
<script src="https://sunpe.github.io/js/scripts.js"></script>

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-161915530-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?567e1c9bcb80e3b8c4f1c1dbf8bb9fab";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>
</body>

</html>

