<!doctype html><html lang=en><head><title>数据结构--栈 - hello world</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="stay foolish, stay hungry"><meta name=author content="sunpeng"><meta name=baidu-site-verification content="vWQN0uJLC2"><meta property="og:title" content="数据结构--栈"><meta property="og:description" content="栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置叫表的末端，或者叫栈顶（top）。由于对栈中所有元素的操作都是在栈顶，所以栈有后进先出（LIFO）的特性。"><meta property="og:type" content="article"><meta property="og:url" content="https://sunpe.github.io/posts/2020-04-03-data-struct-stack/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-03T22:00:00+08:00"><meta property="article:modified_time" content="2020-04-03T22:00:00+08:00"><meta name=generator content="Hugo 0.120.4"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=https://sunpe.github.io/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://sunpe.github.io/css/styles.css></head><body><div id=container><header><h1><a href=https://sunpe.github.io/>hello world</a></h1><ul id=social-media></ul><p><em>stay foolish, stay hungry</em></p></header><nav><ul><li><a href=https://sunpe.github.io/><i class="fa-li fa fa-lg"></i><span>Home</span></a></li><li><a href=https://sunpe.github.io/posts/><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://sunpe.github.io/tags/><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://sunpe.github.io/categories/><i class="fa-li fa fa-lg"></i><span>Categories</span></a></li><li><a href=https://sunpe.github.io/about/><i class="fa-li fa fa-lg"></i><span>About</span></a></li></ul></nav><main><article><h1>数据结构--栈</h1><aside><ul><li><time class=post-date datetime=2020-04-03T22:00:00+08:00>Apr 3, 2020</time></li><li>Categories:
<em><a href=https://sunpe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84>数据结构</a></em></li><li>Tags:
<em><a href=https://sunpe.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84>#数据结构</a></em></li><li>2 minutes read</li></ul></aside><div class=featured_image><a href=https://sunpe.github.io/posts/2020-04-03-data-struct-stack/ title=数据结构--栈><img src></a></div><p>栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置叫表的末端，或者叫栈顶（top）。由于对栈中所有元素的操作都是在栈顶，所以栈有后进先出（LIFO）的特性。</p><p><img src=https://sunpe.github.io/images/data_struct_stack/1.png alt>
图 1</p><p>栈的基本操作有：</p><ul><li>元素入栈操作 <code>push</code></li><li>元素出栈操作 <code>pop</code></li><li>查看栈顶元素 <code>top</code></li></ul><p>入栈是指在栈顶插入元素，出栈是指删除栈顶元素。</p><h2 id=栈的实现>栈的实现</h2><h2 id=通过链表实现>通过链表实现</h2><p>可以使用单链表来实现栈，链表的前端作为栈顶，通过在链表头插入元素来实现 push，删除表头元素来实现 pop，top 操作只是返回链表头部元素的指。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;container/list&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Stack</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>List</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>New</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>Stack</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Stack</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>l</span>: <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>New</span>(),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Stack</span>) <span style=color:#a6e22e>Push</span>(<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>PushFront</span>(<span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Stack</span>) <span style=color:#a6e22e>Pop</span>() <span style=color:#66d9ef>interface</span>{} {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ele</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Front</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>ele</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Stack</span>) <span style=color:#a6e22e>Top</span>() <span style=color:#66d9ef>interface</span>{} {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>RLock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>RUnlock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Front</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=通过-slice-实现>通过 slice 实现</h3><p>使用 slice 实现栈比较简单，先声明一个初始容量比较大的 slice，空栈时栈顶 index(top) 可以设置为 -1，有新元素 x 入栈操作，可以将栈顶index(top) 的值加 1，然后设置 stack[top]=x；元素出栈操作，可以先返回 stack[top]，然后将栈顶 index(top) 的值减 1。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Stack</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>   []<span style=color:#66d9ef>interface</span>{}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>top</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>   <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>capacity</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Stack</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Stack</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>s</span>:   make([]<span style=color:#66d9ef>interface</span>{}, <span style=color:#a6e22e>capacity</span>),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span>:   <span style=color:#a6e22e>capacity</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>top</span>: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Stack</span>) <span style=color:#a6e22e>Push</span>(<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>top</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> &gt; <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>c</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#e6db74>&#34;stack over flow&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>top</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>top</span>] = <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Stack</span>) <span style=color:#a6e22e>Pop</span>() <span style=color:#66d9ef>interface</span>{} {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>top</span> <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#e6db74>&#34;empty stack&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ele</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>top</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>top</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ele</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Stack</span>) <span style=color:#a6e22e>Top</span>() <span style=color:#66d9ef>interface</span>{} {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>RLock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>RUnlock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>top</span> <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#e6db74>&#34;empty stack&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>top</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=总结>总结</h2><p>栈实现简单，效率很高，通常 push 和 pop 都是 O(1) 的操作。错误检测和线程安全方面的考虑可能会拖慢栈的执行效率，对空栈的 pop 和对满栈的 push 可能都会导致程序异常。在golang中实现栈还有一个问题是，golang目前没有支持泛型（generic）或者类型参数（type params），所以编写通用的数据结构只能使用 interface，这样带来的问题是，无法在数据结构的实现中来保证数据类型的安全，使用时需要多加注意。</p><h2 id=参考资料>参考资料</h2><ol><li>数据结构与算法分析</li></ol></article><section class=post-nav><ul><li><a href=https://sunpe.github.io/posts/2020-03-20-data-struct-list/><i class="fa fa-chevron-circle-left"></i> 数据结构--列表</a></li><li><a href=https://sunpe.github.io/posts/2020-04-17-data-struct-queue/>数据结构--队列 <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>Copyright © 2022 - sunpeng |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://sunpe.github.ioindex.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://sunpe.github.io/js/scripts.js></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-161915530-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><script id=baidu_analytics>var _hmt=_hmt||[];(function(){if(window.location.hostname==="localhost")return;var t,e=document.createElement("script");e.async=!0,e.src="https://hm.baidu.com/hm.js?567e1c9bcb80e3b8c4f1c1dbf8bb9fab",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script><script id=baidu_push>(function(){if(window.location.hostname==="localhost")return;var t,n,e=document.createElement("script");e.async=!0,n=window.location.protocol.split(":")[0],n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>