<!doctype html>

<html lang="en">

<head>
  <title>hello world</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="stay foolish, stay hungry" />
<meta name="author" content="sunpeng" />


<meta name="baidu-site-verification" content="vWQN0uJLC2" />
<link rel="alternate" type="application/rss+xml+xml" href="https://sunpe.github.io/index.xml" title="hello world" /><meta property="og:title" content="hello world" />
<meta property="og:description" content="stay foolish, stay hungry" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://sunpe.github.io/" />
<meta property="og:updated_time" content="2020-12-12T22:00:00+08:00" />

<meta name="generator" content="Hugo 0.75.1" />
    

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://sunpe.github.io/fontawesome/css/all.min.css" />
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  
  
  <link rel="stylesheet" type="text/css" href="https://sunpe.github.io/css/styles.css" /></head>

<body>
  <div id="container">
    <header>
      <h1>
        <a href="https://sunpe.github.io/">hello world</a>
      </h1>

      <ul id="social-media">
      </ul>
      
      <p><em>stay foolish, stay hungry</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://sunpe.github.io/">
                <i class="fa-li fa  fa-lg"></i><span>Home</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/posts/">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/tags/">
                <i class="fa-li fa  fa-lg"></i><span>Tags</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/categories/">
                <i class="fa-li fa  fa-lg"></i><span>Categories</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://sunpe.github.io/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<section id="home">
  <ul>
    
    
    

    <li class="first" >
      <h1><a href="https://sunpe.github.io/posts/2020-12-12-solid/" title="面向对象的设计原则-SOLID">面向对象的设计原则-SOLID</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-12-12T22:00:00&#43;08:00">Dec 12, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">软件开发</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">#软件开发</a>
                
            </em>
        </li>
        

        <li>3 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-12-12-solid/" title="面向对象的设计原则-SOLID">
        <img src="">
    </a>
</div>


      <p>单一职责原则（Single responsibility principle，SRP） 简介 就一个类而言，应该仅有一个引起它变化的原因。
如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责变化可能会抑制或消弱类完成其他职责的能力，这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。
图 1 所示，Retangle 类具有两个方法，一个方法用来绘制矩形，一个方法用来计算矩形面积。有两个应用程序使用 Rectangle 类，只会使用 Rectangle 类计算矩形面积的方法，另外一个应用程序只会在屏幕上绘制矩形。
图1 多于一个的职责
Rectangle 类具有两个职责，违反了 SRP。带来的问题，首先，必须在 ComputationalGeometryApplication 中包含 绘制矩形 代码；其次，如果 GraphicalApplication 的改变由于一些原因导致 Rectangle 类的改变，这个改变需要重新构建、测试并部署 ComputationalGeometryApplication，否则 ComputationalGeometryApplication 可能会以不可预测的方式出现问题。</p>
      
      <a href="https://sunpe.github.io/posts/2020-12-12-solid/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-11-25-principles-of-agile-software-development/" title="敏捷软件开发原则">敏捷软件开发原则</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-11-25T22:00:00&#43;08:00">Nov 25, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">软件开发</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">#软件开发</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-11-25-principles-of-agile-software-development/" title="敏捷软件开发原则">
        <img src="">
    </a>
</div>


      <p>我们最优先要做的是通过连续不断的及早的交付有价值的软件使客户满意 《Product-Development Practices That Work: How Internet Companies Build Software》论文分析了对于公司构建高质量产品方面有帮助的软件开发实践, 发现尽早交付具有部分功能的系统和系统质量之间具有很强的相关性, 论文指出 初期交付的系统中所包含的功能越少, 最终交付的系统质量就会越高. 该论文的另一项发现是, 以逐渐增加功能的方式经常性的交付系统和最终质量之间有着非常强的相关性, 交付的越频繁, 最终产品的质量就越高.
敏捷实践会尽早、经常的进行交付, 我们努力在项目刚开始的几周内交付一个具有基本功能的系统, 然后努力坚持每两周就交付一个功能渐增的系统.</p>
      
      <a href="https://sunpe.github.io/posts/2020-11-25-principles-of-agile-software-development/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-11-20-manifesto-for-agile-software-development/" title="敏捷软件开发宣言">敏捷软件开发宣言</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-11-20T22:00:00&#43;08:00">Nov 20, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">软件开发</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">#软件开发</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-11-20-manifesto-for-agile-software-development/" title="敏捷软件开发宣言">
        <img src="">
    </a>
</div>


      <p>由于看到众多团队陷入了不断增长的过程的泥潭，一批业界专家概括出了一些可以让软件开发团队具有快速工作、响应变化能力的价值观和原则，这些专家称自己为敏捷（Agile）联盟，并创造出了一份价值观声明，也就是敏捷联盟宣言。
个体和交互胜过过程和工具 人是获得成功的最主要因素。如果团队中没有优秀的成员，那么就是再好的过程也不能挽救失败的项目。但是不好的过程可以使优秀的团队成员失去作用。如果团队成员不能作为一个团队进行工作，那么即使拥有一批优秀的成员也一样会失败。
一个优秀的团队成员不一定要是一个一流的程序员，可以是一个平均水平的程序员，但是却能够很好的和他人合作。合作、 沟通以及交互能力要比单纯的编程能力更重要。
合适的工具非常重要，比如编译器、 IDE、 源码管理系统等。然而使用过多的庞大、笨重的工具和缺少工具一样，都是不好的。大而笨重的工具带来的障碍往往大于带来的帮助。从使用小工具开始，感觉工具不够用了再去寻找先进的、价格昂贵的工具。
团队的构建比环境构建要重要的多。许多管理者往往希望先构建环境，然后期望团队可以自动凝聚在一起， 然而往往事与愿违。应该首先致力于团队建设，然后再让团队基于需要来配置环境。
可以工作的软件胜过面面俱到的文档 没有文档的软件是一种灾难，代码不是传达系统原理和结构的理想媒介，团队更需要编写易于阅读的文档，来描述系统以及其他设计决策的依据。
然而，过多的文档比过少的文档更糟糕。编制众多的文档需要花费大量时间，并且要使文档和代码保持同步就需要花费更多时间，如果代码和文档之间失去了同步，那么文档就失去了作用，甚至会造成误导。
对于团队来说，有必要编写并维护一份系统原理和结构方面的文档，文档应该是篇幅短小的并且主题突出的，应该仅论述系统的高层结构和概括的设计原理。
在给新的团队成员传授知识方面，最好的两份文档就是代码和团队。代码真实的表达了它所做的事情，是唯一没有二义性的信息源。在团队成员的大脑中，保存着市场变化的系统脉络图，人和人之间的交互是把这份脉络图传授给他人的最快、最有效的方式。
所以直到迫切需要并且意义重大时，才来编制文档。
客户合作胜过合同谈判 告诉研发团队想要的东西，然后期望研发团队消失一段时间后就能够交付一个需要的系统，这对于公司的管理者来说是具有诱惑力的，然后这种模式终将导致低劣的质量和失败。成功的项目需要有序、频繁的客户反馈。
一个指明了需求、进度以及项目成本的合同存在根本上的缺陷，那些为研发团队和客户的协同工作方式提供指导的合同才是最好的合同。
响应变化胜过遵循计划 响应变化的能力常常决定着一个软件的成败，当我们构建计划时，应当确保计划是灵活的，并且易于适应商务和技术方面的变化。</p>
      
      <a href="https://sunpe.github.io/posts/2020-11-20-manifesto-for-agile-software-development/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-11-10-the-smell-of-software-corruption/" title="设计的臭味—软件腐化的气味">设计的臭味—软件腐化的气味</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-11-10T22:00:00&#43;08:00">Nov 10, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">软件开发</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">#软件开发</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-11-10-the-smell-of-software-corruption/" title="设计的臭味—软件腐化的气味">
        <img src="">
    </a>
</div>


      <p>设计不是一组和代码分离的UML图, UML图也许描绘了设计的一部分, 但是它不是设计. 软件项目的设计是一个抽象的概念, 和程序的概括形状(shape)、结构、以及每一个模块、类和方法的详细形状和结构有关, 可以使用不同的媒介去描绘它, 但最终体现为源码, 最后, 源码就是设计.
设计的臭味—软件腐化的气味 项目刚开始甚至首次发布时, 系统设计是清晰的, 随着时间流失, 丑陋的设计和弊病在代码中积累, 使其越来越难以维护, 最后仅仅是最简单的更改也要花费巨大的代价, 以至于开发人员和一线管理人员强烈要求重新设计. 这样的设计很少会成功, 老系统不断发展和变化, 新的设计必须跟上这些变化, 所以新系统第一次发布就积累了很多瑕疵和弊病.</p>
      
      <a href="https://sunpe.github.io/posts/2020-11-10-the-smell-of-software-corruption/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-10-30-use-case-of-cache/" title="缓存常见问题">缓存常见问题</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-10-30T22:00:00&#43;08:00">Oct 30, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1">系统设计</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E7%BC%93%E5%AD%98">#缓存</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-10-30-use-case-of-cache/" title="缓存常见问题">
        <img src="">
    </a>
</div>


      <p>Redis 一个比较常见的场景就是作为应用的缓存，合理的利用缓存可以提升系统性能，使用过程中比较常见的问题有：缓存穿透、 缓存雪崩、 热点key问题。
缓存击穿 在做数据库缓存的使用场景中，我们通常会先从 Redis 中查询数据，如果在 Redis 中查询不到数据，则会查询数据库中的数据。如果查询的是不存在的数据，比如 id 是「-1」的用户，则会导致每次请求都会去数据库中查询，如果这种请求过多，会导致数据库压力过大，造成缓存击穿问题。
解决「缓存击穿」问题大致有三种方案，从业务角度解决、缓存空值和采用布隆过滤器。
从业务角度解决 可以判断查询的数据是否符合规范，比如小于 0 的 ID 可以不进行查询。查询前先校验要查询的 ID 是否是符合规范的 ID。</p>
      
      <a href="https://sunpe.github.io/posts/2020-10-30-use-case-of-cache/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-10-17-make-sure-goroutine-willstop/" title="开启goroutine前确保goroutine可以退出">开启goroutine前确保goroutine可以退出</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-10-17T22:00:00&#43;08:00">Oct 17, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-10-17-make-sure-goroutine-willstop/" title="开启goroutine前确保goroutine可以退出">
        <img src="">
    </a>
</div>


      <p>golang 可以通过 goroutine 来实现高并发，并且创建 goroutine 的开销很小，可以很轻松的创建成千上万的 goroutine。但有个问题需要注意，在创建 goroutine 之前，必须要清楚创建的 goroutine 将如何退出，否则 goroutine 将常驻内存，可能会导致内存泄漏等问题。
程序 1 展示了因为 goroutine 导致内存泄漏的 demo。leak 函数中，创建一个channel，并启动一个goroutine 来消费这个channel。这个 goroutine 结束的唯一条件是关闭 ch。但是 leak 函数返回之后，ch 没有被关闭，这样 goroutine 会一直在内存中，随着 leak 函数调用次数的增多，占用内存也随着增长，最终导致内存泄漏。</p>
      
      <a href="https://sunpe.github.io/posts/2020-10-17-make-sure-goroutine-willstop/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-09-26-hot-account/" title="热点账户处理">热点账户处理</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-09-26T22:00:00&#43;08:00">Sep 26, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1">系统设计</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1">#系统设计</a>
                
            </em>
        </li>
        

        <li>One minute read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-09-26-hot-account/" title="热点账户处理">
        <img src="">
    </a>
</div>


      <p>互联网交易中，当某一商家交易量大的时候，商家对应的账户更新的比较频繁，该商家对应的账户记录会变成热点行，该商家的账户就是热点账户。通常热点账户会导致各种系统问题，对数据库也会造成很大压力。
热点账户分类 根据资金流动的方向可以把热点账户分为「加频账户」、「减频账户」和「双频账户」。 其中「加频账户」是指资金流入比较频繁的账户，比如商家的收款账户；「减频账户」是指资金流出比较频繁的账户，比如商家的退款账户；「双频账户」指流入和流出都比较频繁的账户，比如商家在电商平台开设的内部户。
热点账户识别 在交易系统中可以通过提前配置、 实时统计和同步的方式来识别热点账户。历史的热点账户可以提前配置到系统中，在交易过程中可以利用流式计算的思路实时统计账户请求量，当请求量达到阈值将账户信息同步到系统的热点账户名单中。系统整体架构如图 1 所示。
图 1
热点账户问题解决方案 1. 限流 热点账户问题的根源是大量请求并发竞争账户的操作权，账户的操作权是稀缺资源，所以我们可以减少单位时间内对账户的操作次数，所以「限流」通常是最直接有效的解决方式。限流简单来说就是超出我能力范围的不处理。如图 2 所示。
图 2
虽然限流能明显减少对账户的操作，但限流是通过拒绝交易来达到目的，通常会影响客户体验，这种方式通常作为系统保障的兜底措施。</p>
      
      <a href="https://sunpe.github.io/posts/2020-09-26-hot-account/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-09-04-golang-memory-analyst/" title="golang 语言机制之内存剖析">golang 语言机制之内存剖析</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-09-04T22:00:00&#43;08:00">Sep 4, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>6 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-09-04-golang-memory-analyst/" title="golang 语言机制之内存剖析">
        <img src="">
    </a>
</div>


      <p>《Golang 语言机制之逃逸分析》中介绍了编译器逃逸分析的基础知识，除了共享变量这种情况之外，还有其他情况也会导致变量逃逸。
示例代码 示例代码是读取byte数组，找到 elvis 字符串并替换成 Elvis。示例代码在 https://play.golang.org/p/n_SzF4Cer4，benchmark 在 https://play.golang.org/p/TnXrxJVfLV。示例代码中有两个函数实现这个功能，这篇文章只关注其中的 algOne 函数。
以下是入参和期望 algOne 函数输出的结果。
Input: abcelvisaElvisabcelviseelvisaelvisaabeeeelvise l v i saa bb e l v i saa elvi selvielviselvielvielviselvi1elvielviselvis Output: abcElvisaElvisabcElviseElvisaElvisaabeeeElvise l v i saa bb e l v i saa elvi selviElviselvielviElviselvi1elviElvisElvis 程序 1 是 algOne 函数代码。</p>
      
      <a href="https://sunpe.github.io/posts/2020-09-04-golang-memory-analyst/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-07-31-golang-escape/" title="golang语言机制之逃逸分析">golang语言机制之逃逸分析</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-07-31T22:00:00&#43;08:00">Jul 31, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>3 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-07-31-golang-escape/" title="golang语言机制之逃逸分析">
        <img src="">
    </a>
</div>


      <p>Golang 中逃逸是只栈空间的变量逃逸到了堆空间，逃逸分析是编译器通过静态代码分析决定程序中变量存储位置的过程。代码中没有任何的关键词或者函数可以决定变量放置在栈空间还是堆空间，只能让编译器通过代码来决定变量值的存储位置。
堆（Heaps） 堆是内存中除了栈之外用来存储变量值的区域，堆不能像栈一样自己释放空间，所以使用这块区域会比使用栈有更大的开销。其中开销主要用来进行垃圾回收（GC），当进行垃圾回收时，会消耗 25% 的 CPU，并且很可能会造成微秒级的「stop the world」延迟。而 GC 的好处是不需要再手动来分配和释放内存。Golang 中一部分变量值分配在堆上，而不在使用的变量值都需要清理掉，堆上的数据过多会给 GC 造成压力。
共享栈（Sharing Stacks） Golang 不允许 goroutine 访问其他 goroutine 的栈空间，这是因为 goroutine 的栈空间增长或收缩时，栈空间会填充进新的内容。</p>
      
      <a href="https://sunpe.github.io/posts/2020-07-31-golang-escape/">Read more…</a>
      
    </li>
    

    <li >
      <h1><a href="https://sunpe.github.io/posts/2020-07-17-golang-stack-and-pointer/" title="golang语言机制之栈与指针">golang语言机制之栈与指针</a></h1>
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-07-17T22:00:00&#43;08:00">Jul 17, 2020</time>
        </li>
        
        
        <li>
            Categories:
            <em>
                
                    
                    <a href="https://sunpe.github.io/categories/golang">golang</a>
                
            </em>
        </li>
        

        
        <li>
            Tags:
            <em>
                
                    
                    <a href="https://sunpe.github.io/tags/golang">#golang</a>
                
            </em>
        </li>
        

        <li>3 minutes read</li>
    </ul>
</aside>

      
<div class="featured_image">
    <a href="https://sunpe.github.io/posts/2020-07-17-golang-stack-and-pointer/" title="golang语言机制之栈与指针">
        <img src="">
    </a>
</div>


      <p>学习和使用 golang，就不得不了解 golang 的指针。如果不能很好的理解指针，很难写出简单、整洁并高效的代码。
帧边界（Frame Boundaries） 帧边界为函数执行提供了独有的内存空间、上下文（context）环境和一些流控制。函数可以通过帧边界指针直接访问帧边界的内存，或者间接访问帧边界外的内存（不能直接访问帧边界外的内存）。函数要间接访问帧边界外的内存，被访问的内存必须和函数共享。我们首先来了解一下帧边界建立的机制和限制。
函数调用时，会在两个相关的帧边界间进行切换，从调用函数切换到被调用函数，如果函数调用时需要传递参数，那么这些参数值也要传递到被调用函数的帧边界中。Go 语言中帧边界间的数据传递是按值（by value）传递的。
按值传递的好处是可读性好，函数调用时传入的值就是函数真正接收到的值。按值传递又叫做 WYSIWYG（what you see is what you get）。在发生切换时，我们可以很清楚的了解函数调用将如何影响程序执行。
程序 1 展示了函数调用按值传递。</p>
      
      <a href="https://sunpe.github.io/posts/2020-07-17-golang-stack-and-pointer/">Read more…</a>
      
    </li>
    
  </ul>
</section>


<ul class="pagination">
  <li class="page-item">
    <a href="https://sunpe.github.io/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="https://sunpe.github.io/">1</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="https://sunpe.github.io/page/2/">2</a>
  </li>
  <li class="page-item">
    <a href="https://sunpe.github.io/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="https://sunpe.github.io/page/2/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>





</main>
    <footer>
        <h6>Copyright © 2020 - sunpeng |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://sunpe.github.ioindex.xml">Subscribe </a></h6>
    </footer>
</div>
<script src="https://sunpe.github.io/js/scripts.js"></script>

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-161915530-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?567e1c9bcb80e3b8c4f1c1dbf8bb9fab";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>
</body>

</html>

