<!doctype html><html lang=en><head><title>golang map - hello world</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="stay foolish, stay hungry"><meta name=author content="sunpeng"><meta name=baidu-site-verification content="vWQN0uJLC2"><meta property="og:title" content="golang map"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://sunpe.github.io/posts/2021-11-24-golang-map/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-24T22:00:00+08:00"><meta property="article:modified_time" content="2021-11-24T22:00:00+08:00"><meta name=generator content="Hugo 0.121.1"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=https://sunpe.github.io/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://sunpe.github.io/css/styles.css></head><body><div id=container><header><h1><a href=https://sunpe.github.io/>hello world</a></h1><ul id=social-media></ul><p><em>stay foolish, stay hungry</em></p></header><nav><ul><li><a href=https://sunpe.github.io/><i class="fa-li fa fa-lg"></i><span>Home</span></a></li><li><a href=https://sunpe.github.io/posts/><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=https://sunpe.github.io/tags/><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li><li><a href=https://sunpe.github.io/categories/><i class="fa-li fa fa-lg"></i><span>Categories</span></a></li><li><a href=https://sunpe.github.io/about/><i class="fa-li fa fa-lg"></i><span>About</span></a></li></ul></nav><main><article><h1>golang map</h1><aside><ul><li><time class=post-date datetime=2021-11-24T22:00:00+08:00>Nov 24, 2021</time></li><li>Categories:
<em><a href=https://sunpe.github.io/categories/golang>golang</a></em></li><li>Tags:
<em><a href=https://sunpe.github.io/tags/golang>#golang</a></em></li><li>4 minutes read</li></ul></aside><div class=featured_image><a href=https://sunpe.github.io/posts/2021-11-24-golang-map/ title="golang map"><img src></a></div><p><img src=https://sunpe.github.io/images/golang_map/1.png alt></p><h2 id=hmap>hmap</h2><p>map 是引用类型，指针指向 hmap 结构体，hmap 的 <a href=https://github.com/golang/go/blob/master/src/runtime/map.go#L116>源码</a> 如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span>     <span style=color:#66d9ef>int</span> <span style=color:#75715e>// # live cells == size of map.  Must be first (used by len() builtin)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>flags</span>     <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>B</span>         <span style=color:#66d9ef>uint8</span>  <span style=color:#75715e>// log_2 of # of buckets (can hold up to loadFactor * 2^B items)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>noverflow</span> <span style=color:#66d9ef>uint16</span> <span style=color:#75715e>// approximate number of overflow buckets; see incrnoverflow for details
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>hash0</span>     <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// hash seed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>buckets</span>    <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// array of 2^B Buckets. may be nil if count==0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>oldbuckets</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// previous bucket array of half the size, non-nil only when growing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>nevacuate</span>  <span style=color:#66d9ef>uintptr</span>        <span style=color:#75715e>// progress counter for evacuation (buckets less than this have been evacuated)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>extra</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mapextra</span> <span style=color:#75715e>// optional fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>count 表示map中元素个数</li><li>flags 是一个状态标识，有4个值，分别是</li></ul><pre tabindex=0><code>iterator     = 1 // there may be an iterator using buckets
oldIterator  = 2 // there may be an iterator using oldbuckets
hashWriting  = 4 // a goroutine is writing to the map
sameSizeGrow = 8 // the current map growth is to a new map of the same size
</code></pre><ul><li>B 表示桶个数的对数</li><li>noverflow 是溢出桶个数的近似值</li><li>buckets 指向 bmap 数组</li><li>oldbuckets 和扩容有关，指向扩容时的旧桶</li></ul><h2 id=bmap>bmap</h2><p><img src=https://sunpe.github.io/images/golang_map/2.png alt></p><p>hmap 中的 buckets 和 oldbuckets 指向的是 bmap 数组，一个 bmap 可以放 8 个元素，bmap <a href=https://github.com/golang/go/blob/master/src/runtime/map.go#L150>源码</a>，编译过程会加料，最终 bmap 结构体会是这样的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>tophash</span>  [<span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>keys</span>     [<span style=color:#ae81ff>8</span>]<span style=color:#a6e22e>keytype</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>values</span>   [<span style=color:#ae81ff>8</span>]<span style=color:#a6e22e>valuetype</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pad</span>      <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>overflow</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>tophash 存储 hash 值的高8位，需要注意的是，tophash 值小于等于 5 存储的是状态。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>emptyRest</span> = <span style=color:#ae81ff>0</span> <span style=color:#75715e>// this cell is empty, and there are no more non-empty cells at higher indexes or overflows.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>emptyOne</span> = <span style=color:#ae81ff>1</span> <span style=color:#75715e>// this cell is empty
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>evacuatedX</span> = <span style=color:#ae81ff>2</span> <span style=color:#75715e>// key/elem is valid.  Entry has been evacuated to first half of larger table.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>evacuatedY</span> = <span style=color:#ae81ff>3</span> <span style=color:#75715e>// same as above, but evacuated to second half of larger table.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>evacuatedEmpty</span> = <span style=color:#ae81ff>4</span> <span style=color:#75715e>// cell is empty, bucket is evacuated.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>minTopHash</span> = <span style=color:#ae81ff>5</span> <span style=color:#75715e>// minimum tophash for a normal filled cell.
</span></span></span></code></pre></div><p>通过 key 的 hash 值和 B-1 做与运算，判断元素落在哪个桶中，在通过 tophash 确定在桶的位置，然后根据 tophash 判断 bucket 的该位置是否可用，如果 8 个位置都不可用，则会链出一个指针指向一个新的 bmap 作为溢出桶。</p><p>当 map 的 key 和 value 都不是指针，并且 size 都小于 128 字节的时候，会把 bmap 标记为不含指针，以避免 GC 扫描整个 hmap。这时候 overflow 指针会被放到 mapextract 中，以保证 bmap 中不包含指针。</p><h2 id=loadfactor>loadfactor</h2><p>golang map 的 loadfactor 为 6.5。</p><h2 id=make-map>make map</h2><p>创建 map 会调用 makemap 函数，函数 <a href=https://github.com/golang/go/blob/master/src/runtime/map.go#L304>源码</a>。</p><p>创建 map 的流程如下：</p><ul><li>计算 B</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>B</span> <span style=color:#f92672>:=</span> uint8(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>hint</span>, <span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>B</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> = <span style=color:#a6e22e>B</span>
</span></span></code></pre></div><ul><li>如果 B != 0, 则申请桶空间</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>makeBucketArray</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span> = new(<span style=color:#a6e22e>mapextra</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>nextOverflow</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=mapaccess>mapaccess</h2><p>由于读取 map 的返回值有三种，所以函数有三个，分别对应着返回单个值、返回值和bool，返回key和value。 <a href=https://github.com/golang/go/blob/master/src/runtime/map.go#L395>mapaccess1</a>, <a href=https://github.com/golang/go/blob/master/src/runtime/map.go#L456>mapaccess2</a>, <a href=https://github.com/golang/go/blob/master/src/runtime/map.go#L518>mapaccessK</a>。</p><p>读取流程如下：</p><ul><li>计算 key 的 hash</li><li>用 key 的 hash 的低 B 位定位桶</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>key</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))
</span></span><span style=display:flex><span><span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, (<span style=color:#a6e22e>hash</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span></code></pre></div><ul><li>判断是否需要从旧桶里找</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span>; <span style=color:#a6e22e>c</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>m</span> <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>oldb</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>c</span>, (<span style=color:#a6e22e>hash</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>evacuated</span>(<span style=color:#a6e22e>oldb</span>) { <span style=color:#75715e>// 判断 top hash 是不是 evacuatedX 或 evacuatedY
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>oldb</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>取 top hash</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)
</span></span></code></pre></div><ul><li>通过 top hash 和 key 在桶内查找 key</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>b</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>; <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>top</span> { 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>emptyRest</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>bucketloop</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>k</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>k</span>))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>e</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>e</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=https://sunpe.github.io/images/golang_map/3.png alt></p><h2 id=mapassign>mapassign</h2><p>写入数据会调用 mapassign 函数，写数据和读数据的流程相似，只不过多了扩容判断。</p><ul><li>首先判断是否是并发写入， 并设置 flags</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hashWriting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fatal</span>(<span style=color:#e6db74>&#34;concurrent map writes&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> ^= <span style=color:#a6e22e>hashWriting</span>
</span></span></code></pre></div><ul><li>判断是否需要扩容</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>bucket</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>growWork</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>bucket</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>定位桶和计算hash top</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>bucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span><span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)
</span></span></code></pre></div><ul><li>遍历桶找到插入的位置</li><li>如果key 存在，则更新</li><li>修改flags</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>&amp;^=</span> <span style=color:#a6e22e>hashWriting</span>
</span></span></code></pre></div><h2 id=mapdelete>mapdelete</h2><p>删除操作调用 <a href=https://github.com/golang/go/blob/master/src/runtime/map.go#L695>mapdelete</a> 函数。</p><ul><li>写保护</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hashWriting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fatal</span>(<span style=color:#e6db74>&#34;concurrent map writes&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> ^= <span style=color:#a6e22e>hashWriting</span>
</span></span></code></pre></div><ul><li>确定桶的位置</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>key</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))
</span></span><span style=display:flex><span><span style=color:#a6e22e>bucket</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span></code></pre></div><ul><li>判断扩容</li><li>遍历桶寻找key，找到key则删除元素并更新 tophash</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>e</span>) = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>ptrdata</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memclrHasPointers</span>(<span style=color:#a6e22e>e</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memclrNoHeapPointers</span>(<span style=color:#a6e22e>e</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>emptyOne</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><ul><li>解除写保护</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>&amp;^=</span> <span style=color:#a6e22e>hashWriting</span>
</span></span></code></pre></div><h2 id=扩容>扩容</h2><p><a href=https://github.com/golang/go/blob/master/src/runtime/map.go#L1041>扩容代码</a></p><ul><li>如果 loadfactor 超过6.5，触发翻倍扩容</li><li>如果溢出桶过多则触发等量扩容</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>tooManyOverflowBuckets</span>(<span style=color:#a6e22e>noverflow</span> <span style=color:#66d9ef>uint16</span>, <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>uint8</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>B</span> &gt; <span style=color:#ae81ff>15</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>B</span> = <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>noverflow</span> <span style=color:#f92672>&gt;=</span> uint16(<span style=color:#ae81ff>1</span>)<span style=color:#f92672>&lt;&lt;</span>(<span style=color:#a6e22e>B</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>15</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>扩容过程为渐进式扩容</li></ul></article><section class=post-nav><ul><li><a href=https://sunpe.github.io/posts/2021-08-17-golang-gzip-troubleshooting/><i class="fa fa-chevron-circle-left"></i> golang gzip 使用过程中问题排查</a></li><li><a href=https://sunpe.github.io/posts/2022-07-20-gin-open-pprof/>Gin 开启pprof <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><ul><li><h6>Copyright © 2022 - sunpeng |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://sunpe.github.ioindex.xml>Subscribe</a></h6></li></ul></footer></div><script src=https://sunpe.github.io/js/scripts.js></script><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-161915530-1","auto"),ga("send","pageview"))</script><script id=baidu_analytics>var _hmt=_hmt||[];(function(){if(window.location.hostname==="localhost")return;var t,e=document.createElement("script");e.async=!0,e.src="https://hm.baidu.com/hm.js?567e1c9bcb80e3b8c4f1c1dbf8bb9fab",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script><script id=baidu_push>(function(){if(window.location.hostname==="localhost")return;var t,n,e=document.createElement("script");e.async=!0,n=window.location.protocol.split(":")[0],n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>